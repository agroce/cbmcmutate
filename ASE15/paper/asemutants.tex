
%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[conference]{IEEEtran}
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.

\usepackage{code}



% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{How Verified is My Code?\\Understanding
  ``Successful'' Verifications}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Alex Groce, Iftekhar Ahmed, Carlos Jensen}
\IEEEauthorblockA{School of Electrical Engineering and\\Computer  Science\\
Oregon State University, Corvallis, Oregon\\
Email: agroce@gmail.com}
\and
\IEEEauthorblockN{Paul E. McKenney}
\IEEEauthorblockA{IBM Linux Technology Center\\
Email: paulmck@linux.vnet.ibm.com}
}


% make the title area
\maketitle


\begin{abstract}
%\boldmath
\input{abstract}
\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}

Software model checking \cite{ModelChecking} has recently, thanks to
improvements in model checking tools as well as SAT and SMT solvers,
and the large amount of memory available even on commodity
workstations, become a potentially valuable tool for developers of
critical software modules who want to, at minimum, perform a very
aggressive search for bugs and, at best, prove correctness of their
code.  Tools such as CBMC \cite{CBMCp} (the C Bounded Model Checker)
allow a software engineer to model check code by writing what is
essentially a generalized test harness\footnote{By a harness we mean a
  program that defines the environment in which a program is verified,
  provides correctness properties, etc.; in CBMC such a harness looks
  very similar to a harness for more traditional software testing.} in
the language of the Software Under Test (SUT).  Figure
\ref{fig:sortharness} shows a CBMC harness for a sorting routine.

\begin{figure}
{\scriptsize
\begin{code}
\#include <stdio.h>
\#include "sort.h"

int a[MAX\_ITEMS];
int ref[MAX\_ITEMS];

int nondet\_int();

int main () \{
  int i, v, prev;
  int s = nondet\_int();
  \_\_CPROVER\_assume((s > 0) \&\& (s <=MAX\_ITEMS));
  for (i = 0; i < s; i++) \{
    v = nondet\_int();
    printf ("LOG: ref[\%d] = \%d\\n", i, v);
    ref[i] = v;
    a[i] = v;
  \}
  sort(a, s);
  prev = a[0];
  for (i = 0; i < s; i++) \{
    printf ("LOG: a[\%d] = \%d\\n", i, a[i]);
    assert (a[i] >= prev);
    prev = a[i];
  \}
\}
\end{code}
}
\caption{A simple harness for a sorting algorithm.}
\label{fig:sortharness}
\end{figure}

CBMC compiles a harness and the SUT (here a quick sort implementation)
into a goto-program, instruments
this program with property checks for assertions, array bounds
violations, etc., and then unrolls loops based on a user-provided
\emph{unwinding bound} to produce a SAT problem or SMT constraint such
that satisfying assignments are representations of a trace
demonstrating a property violation, known as a \emph{counterexample}
\cite{CountWitness}.  For CBMC, this means that if \emph{any possible execution
  allowed by the harness} violates any properties we are checking, a
counterexample will be produced.  One such property is that no
loop in the program executes more than the \emph{unwinding bound}
times.  For example, if we run CBMC on the harness shown and set the
unwinding depth to 4 and add {\tt -DMAX\_ITEMS=3}, we will check the
correctness of the SUT over all possible arrays of size 3 or less,
including that sorting never requires running any loop more than 4
times (counting the iteration where the bound is exceeded).

When a model checker produces a counterexample,
a developer's task is straightforward, if sometimes difficult: either
the SUT has a fault, or the harness itself is flawed.  In both cases,
the status of the verification effort is clear and the resulting
output (a detailed trace, including the output of any print
statements) is full of evidence as to the reason for the failure to
verify the SUT. Moreover, any solution (fix to SUT or harness) is
easily checked: if it is correct, the model checker stops reporting
the previous counterexample.  

Unfortunately, model checkers do not invariably report
counterexamples: eventually the SUT is likely to satisfy the
properties encoded in the harness!  It is in this case that problems
arise: what, precisely, has been verified?  Does the harness in fact
specify all aspects of correctness required?  Is the SUT correct?
Formal verification is not only subject to the many issues that make
``no faults detected'' results dubious in testing \cite{WODA09,CovDisc}, but
also to more subtle problems.  For example, an incorrect \emph{assume}
statement may constrain a system so that not only are there no
counterexamples, there are no allowable executions of the system at
all!

This problem has concerned the model checking community for some time
\cite{PracticalCov}, and resulted in efforts to define \emph{coverage
  metrics} for model checking.  While such metrics are interesting and
useful, however, they have typically been aimed at the hardware
verification community, and often useful primarily to experts in
formal verification.  In this paper, we adapt traditional mutation
testing \cite{mutation1,mutation2} to the problem of software
verification.  A mutant of a program is a version of the program that
introduces a small syntactic change.  The idea behind mutation testing
is that a good test suite will be able to detect when (as is usually
the case) such a change introduces a bug in the SUT.  In the case of
bounded model checking, since we aim at \emph{verification} rather
than merely good testing, it seems clear that surviving mutants are
likely to indicate a weakness of the verification.

The use of mutation testing most often seen in the software
engineering literature will not suffice in this case: simply noting a
mutation kill rate is not enough.  The typical small scope of the code to be
verified, and the presumed importance of such critical code suggests
an approach in which \emph{individual mutants} are examined by the
developer.  Without additional assistance, such an approach will not
scale.  We show that the capabilities of the model checking tool, the
nature of formal verification, and the adoption of certain best
practices can make this seemingly too-demanding approach in fact
practical for real verification tasks.

Our basic idea is to use mutants throughout the verification
effort, even guiding the choice of an unwinding depth by examining
mutants.  At each stage the developer examines the currently surviving
mutants, either by inspecting the mutated code or (when this does not
make the reason the mutant is not detected clear) looking at
\emph{successful executions covering the mutant but satisfying the
  specification given in the harness}.  For critical verification
tasks, we suggest that developers not only examine the passing
executions of surviving mutants, but the passing executions of
\emph{killed mutants}.  While examining test cases that do not kill a
given mutant could be useful in traditional testing, the model checker
makes a much more potent investigation possible, where a developer can
constrain the behavior to force the mutant's behavior to matter, if
that is possible, and automatically find passing executions that maximize
total branch coverage.  Finally, we propose a developer should use mutants
of the test harness itself to ensure that no similar harness has a
better mutant kill rate, and that most mutants of the harness reject
the SUT itself.

\subsection{A Simple Example Verification}

As an example of the proposed verification methdology, consider again
the harness shown in Figure \ref{fig:sortharness}.  If we take the
first hit on Google for ``quick sort in C'' \cite{quicksortcode},
shown in Figure \ref{fig:qsort}\footnote{In fact, that actual code is
  incorrect, with an access {\tt a[i]} that does not properly
  use short circuiting logical operators to protect array bounds;
  CBMC detected this, and we fixed it for this paper.}, we can model check it using the
harness, defining {\tt MAX\_ITEMS=2} and setting unwinding depth to three (we need one more unwinding than the largest possible number
of items in the array).  CBMC reports {\tt VERIFICATON SUCCESSFUL} in
less than a second.  Does this mean we have verified what we want to
verify?  How do we understand this ``successful'' verification result better?

\begin{figure}
{\scriptsize
\begin{code}
\#include "sort.h"

void quickSort( int a[], int l, int r) \{
  int j;
  if( l < r ) \{
      j = partition( a, l, r);
      quickSort( a, l, j-1);
      quickSort( a, j+1, r);
    \}
\}
int partition( int a[], int l, int r) \{
  int pivot, i, j, t;
  pivot = a[l];
  i = l; j = r+1;
  while(1) \{
      do ++i; while( i <= r && a[i] <= pivot );
      do --j; while( a[j] > pivot );
      if( i >= j ) break;
      t = a[i]; a[i] = a[j]; a[j] = t;
    \}
  t = a[l]; a[l] = a[j]; a[j] = t;
  return j;
\}
void sort(int a[], unsigned int size) \{
  quickSort(a, 0, size-1);
\}

\end{code}
}
\caption{Quick sort code from the web.}
\label{fig:qsort}
\end{figure}

\subsubsection{Finding a Good Unwinding Depth}

The first question we face is whether 2 is really a good maximum array
size to examine.  The problem of determining a \emph{completeness
  threshold} (execution length bound sufficient to prove correctness
in all cases for a given property) for bounded model checking is
fundamentally difficult \cite{CTDaniel} and is, for real-world C
programs, more an art than a science at present\footnote{In our own
  practice, the most common way of setting it is to guess a bound and
  see if the resulting problem is too large for the available
  computational resources.}.  Are there bugs for which 2 is too small
an array size?  In order to find out, we generate a set of mutants for
{\tt quicksort.c}.  Using the mutation tool for C code developed my
Jamie Andrews \cite{mutant}, we can produce 81 mutants of this code in
less than a second.  We then run the harness with unwinding depth 2
(and {\tt MAX\_ITEMS=1}) on each of the 81 mutants.  The process takes
about a minute and a half (on a Macbook Pro with dual-core 3.1GHz
Intel Core i7, but using only one core).  CBMC reports that 6 mutants do not compile (these
remove variable declarations, for the most part), 4 are detected by
the harness, and 71 mutants pass without detection.  Clearly length 1
arrays are not sufficient to detect even the most glaring bugs in a
sort algorithm.  What about our choice of size 2?  Re-running the
mutants (dropping those already killed by the smaller bound) takes
slightly over 6 minutes and reduces the number of surviving mutants to
26.  We could inspect these mutants by hand, but it seems highly
unlikely that a \emph{complete verification} over all possible arrays
with a good specification of sorting would produce such a poor
mutation kill rate.  If we up the size limit to 3 (the verification
taking just over 15 minutes), only 8 mutants survive.  Increasing the
limit to size 4, again the same 8 mutants survive.  We call an
unwinding depth (or, more generally, problem size) such that
increasing it by one does not kill any additional mutants
\emph{mutant-stable}.  In the absence of any further domain specific
knowledge, finding a mutant-stable problem size can serve as a good
heuristic for approximating a completeness threshold.  Obviously,
there is no guarantee that a mutant-stable size is sufficient, but
given the speed with which the computational requirements for checking
even the original program increase with unwinding depth, moving to
larger sizes is inefficient until it is known that the harness and SUT
are likely correct.  Our approach to verification aims to always
minimize both machine and human time spent analyzing versions of
the harness or SUT that are not finalized.

While the time needed for this process may seem excessive for a small
program, note that the results are exhaustive, and of course the
verification problems for each individual mutant and bound can be
solved in parallel.  A more sophisticated algorithm for unwinding
determination (Figure \ref{alg:unwind}) presented later in this paper
further reduces the burden, by moving to larger unwindings as soon as
it is known the current unwinding is not mutant-stable.

\subsubsection{Examining Surviving Mutants}

\begin{figure}
{\scriptsize
\begin{code}
9 :  /*(rep\_op)*/ if (l <= r) 
26 :  /*(rep\_const)*/ while(-1)
26 :  /*(rep\_const)*/ while( ((1)+1))
28 :  /*(rep\_op)*/ do ++i; while(i<r \&\& a[i]<=pivot);
28 :  /*(rep\_op)*/ do ++i; while(i!=r \&\& a[i]<=pivot);
28 :  /*(rep\_op)*/ do ++i; while(i<=r \&\& a[i]<pivot);
30 :  /*(rep\_op)*/ if( i > j ) break;
31 :  /*(del\_stmt)*/ t=a[i]; /*  a[i]=a[j]; */  a[j]=t;
\end{code}
}
\caption{Surviving mutants}
\label{fig:survivors}
\end{figure}

Figure \ref{fig:survivors} shows surviving mutants for our quick sort
code (the comment indicates the type of mutant, and the line\# in the
quick sort file is also given for reference).



\begin{enumerate}
\item Generate mutant set $M = m_1 \ldots m_n$ for the program $P$.
\item Prune $M$ into $M'$ by equivalence classes based on optimizing
  compiler output, removing mutants that fail to compile or are equal
  to the original code.
\item Set unwinding depth/problem size $U$ to 0.
\item Set $r = 0, r' = 1$.
\item While $r != r'$:
\begin{enumerate}
\item Set $U = U + 1$.
\item Set $r = r'$
\item Set $K = \emptyset, S = \emptyset$.
\item Check each mutant $m_i \in M$ using $H$ and size $U$: if $m_i$ is killed, $K = K \cup
  \{m_i\}$, otherwise $S = S \cup \{m_i\}$.
\item Set $r' = |K| / |M|$.  
\end{enumerate}
\item Examine each mutant in $S$.  Remove those that are, by
  inspection, semantically equivalent to $P$.
\item Modify harness $H$ for mutants in $S$ that indicate a clear
  violation of the specification, easily understood, until $H$ kills
  all such mutants.  Remove them from $S$ and add them to $K$.
\item For remaining mutants in $S$, generate a successful execution
  that covers the mutant but satisfied $H$.  If the execution is
  degenerate, add constraints removing that class of execution until a
  witness to an incorrect, mutant-covering behavior is produced.  Use
  this to modify $H$ and move newly killed mutants from $S$ to $K$.
\item Take mutants in $m_i \in K$, and check whether there exists a successful
  execution of $m_i$ satisfying $H$.  Examine and constraint each such
  execution to remove degenerate solutions, modifying $H$ as needed.
\item Compute mutants $M_H$ of the harness, and check that all mutants
  either:  produce a counterexample for the original program $P$ or
  have a kill rate $\leq$ the kill rate for $H$.
\end{enumerate}

\begin{figure}
{\scriptsize
\begin{code}
(int, survivors) unwind($H$, $M$, $O$: options, $U_s$: int) 
\vspace{0.1in}
U = $U_s$-1
r' = \{\}
changed = False
while changed:
   TOP:
   U = U + 1
   changed = False
   r = r'
   r' = \{\}
   for $m \in M$:
      if $m \not\in r$:
         r[m] = check($H$,$m$,$U$,$O(U)$)
         if r[m] == KILLED:
            //once killed, assume always killed
            $M$ = $M \\ m$
      if r[m] == SURVIVED:
         r'[m] = check($H$,$m$,$U$+1,$O(U+1)$)
         if r'[m] == KILLED:
            $M$ = $M \\ m$
            changed = True
            goto TOP
return (U-1, $M$)
\end{code}
}
\caption{Algorithm 1: Finding unwinding depth and surviving mutants}
\label{alg:unwind}
\end{figure}

\begin{figure}
{\scriptsize
\begin{code}
harness covering($H$, $TARGET$)
\vspace{0.1in}
$H'$ = $H$

for stmt $\in H'$:
   if stmt == assert(P):
      stmt = assume(P);

cover = [
  assume(total\_coverage >= TARGET); 
  assert(!mutant\_covered);
]

insert cover at end of $H'$.main()

return $H'$
\end{code}
}
\caption{Algorithm 2: Convert harness into maximal coverage search}
\label{alg:invert}
\end{figure}

Our primary contribution in this paper is a detailed examination of
the extension of traditional mutation testing to understand successful
(and ``successful'') verification results, and determine when a
harness is not actually sufficiently powerful to ensure correctness.
To support this approach, we show how to use mutation testing to
choose an unwinding depth for loops in bounded model checking, how to
mutate a harness to determine if any similar harnesses have an equal
(or better) mutation kill rate, and most importantly, how to
modify CBMC to automatically
produce successful high-coverage executions covering mutated code
in order to understand mutant behavior and find subtle harness flaws.  We also propose the use of
mutation analysis to gain limited confidence of program correctness even
past model checker scalability limits. At a more general level, we
discuss the fundamental nature of ``verification'' in a real-world
context where specifications are never known to be complete. We
propose that falsification, as in certain theories of natural science,
is a more useful conceptual framework for most software verification
efforts: rather than focusing on what can be proven about a program,
it may be best to focus on how a verification effort distinguishes the
``real'' program from similar alternative programs that can be shown
to \emph{not} match the theory of program behavior.

\section{Falsification and Verification}



\section{Algorithms and Techniques}

\begin{figure}
{\scriptsize
\begin{code}
int main () \{
   /* Code to assign asize, bsize, elements of a and b omitted
       due to space limitations. */

  int c[SIZE*2];
  int csize;
  csize = merge\_sorted\_nodups(a, asize, b, bsize, c);
  assert (csize <= (asize + bsize));

  i1 = nondet\_int();
  i2 = nondet\_int();
  \_\_CPROVER\_assume((i1 >= 0) \&\& (i2 >= 0));
  \_\_CPROVER\_assume((i1 < csize) \& \& (i2 < csize));
  \_\_CPROVER\_assume(i1 != i2);
  assert(c[i1] != c[i2]);
  v = nondet\_int();
  \_\_CPROVER\_assume ((v >= 0) \&\& (v < asize));

  v = a[v];
  int found = 0;
  for (i = 0; i < csize; i++) \{
    if (c[i] == v)
      found = 1;
  \}
  assert (found == 1);

  // Do the same for array b
\}
\end{code}
}
\caption{Harness for merge\_sorted\_nodups}
\label{fig:uniqueharness}
\end{figure}

Given a mutant of program $P$, $M_i$, the 

Even a killed mutant (e.g., a mutant the harness detects) can shed
critical light on harness vulnerabilities.  For example, the code in
Figure \ref{fig:uniqueharness} is a portion of a harness to verify
code that merges two sorted arrays, removing all duplicates (the
source arrays may contain duplciates or shared items, the output array
is guaranteed to be sorted and have all-unique values).  This harness
detects all non-equivalent mutants of the source code.  However, as is
well known, many software faults \cite{justmutants} are not
represented by a mutant.  Because we are model checking, we want our
harness to actually rule out \emph{all} bad runs of the program under
test.  Even a killed mutant's passing executions may show such a
problem.  Here we see that when the output array's size is 1, the way
we have written the duplicate check in fact \emph{assume}s away
\emph{all executions}!  We check no properties of size 1 output
arrays, and a fault that only appears with size = 1 will never be
detected.  No mutant produces such behavior, but noting an incorrect
but passing trace of this run lets us see the problem.

\section{Experimental Results and Case Studies}

\section{Related Work}

The idea that a ``successful verification'' often simply indicates an
inadequate property is long-standing \cite{PracticalCov} and the use
of mutants to provide a coverage measure dates back both to these
early explorations and relatively recent work \cite{MutInterp}.
However, in these efforts the mutation was applied to hardware models,
and (critically) the surviving mutants were used to identify
``uncovered'' portions of a model, rather than presented to a
developer for examination and understanding directly.

Our idea of examining successful executions to better understand
surviving (and even killed) mutants is a peculiar variation of the
fault localization and error explanation problem in model checking
\cite{GroceDist}, with the twist being that we are ``explaining'' an
artificial fault that 1) typically does not cause a test failure (for
surviving mutants) and 2) has an obviously known location.

\section{Conclusion}

% use section* for acknowledgement
\section*{Acknowledgment}


The authors would like to thank...





% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
\bibliographystyle{IEEEtran}
\bibliography{bibliography}

% that's all folks
\end{document}
